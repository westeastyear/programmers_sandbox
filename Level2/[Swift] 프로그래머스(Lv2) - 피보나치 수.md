# [Swift] 프로그래머스(Lv2) - 피보나치 수

[문제출처 프로그래머스 - 피보나치 수](https://school.programmers.co.kr/learn/courses/30/lessons/12945)

# 나의 풀이

```swift
func solution(_ n: Int) -> Int {
    var arr = Array(0...n)
    
    for i in 2..<arr.count {
        arr[i] = (arr[i-1] + arr[i-2]) % 1234567
    }
    
    return arr[n]
}
```

- `n`은 2이상만 입력이 되고, 0과 1의 경우 피보나치 수를 구할 필요가 없다.
- 0부터 `n`까지 담을 수 있는 배열을 생성하였다.
- `for-loop`의 시작은 2부터 시작하도록 하였다. 범위는 `arr.count`미만으로 하였다.
    - 피보나치를 구하려면 `arr[i-1]`, `arr[i-2]`로 인덱스 0과 1에 접근해야하기 때문이다.
- 인덱싱으로 `arr[i-1]`와 `arr[i-2]`를 더하고 나머지를 구해서 `arr[i]`에 대입해주었다.
- `arr[n]`리턴!
- 처음에는 나누지 않은 값들을 모두 배열에 담고 나중에 나머지를 구하는 식으로 했었는데 수가 너무 커져서 오류가 발생하였다.
- 이리 저리 대입해보면서 풀었는데 돼서 당황했다…😅

# 리펙토링

```swift
func solution(_ n: Int) -> Int {
    var arr = [0, 1]
    
    for i in 2...n {
        arr.append((arr[i-1] + arr[i-2]) % 1234567)
    }
    return arr[n]
}
```

- 전의 코드에서 `n`까지의 배열을 만든다는것에 의구심이 있었는데 0과 1만 있는 배열을 만들어 놓았다.
- 피보나치 수를 구하면서 생기는 나머지를 `arr`에 `append`하는 방식으로 리펙토링 하였다.
- `arr[n]`을 리턴해야 하기 때문에 `for-loop`범위는 2부터 `n`까지 수정하였다.

# 나머지 연산의 성질

- 모든 단계에서 `%` 연산자를 사용하여, 모든 연산에서 오버플로우가 일어나지 않게 만들 수 있다고 한다.
- 직접 해보았을때 드라마틱한 차이점을 체감하지는 못했다.

```swift
(a + b) % m = ((a % m) + (b % m)) % m
```
