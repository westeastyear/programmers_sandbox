# [Swift] 프로그래머스(Lv2) - 멀리 뛰기

[문제출처 프로그래머스 - 멀리 뛰기](https://school.programmers.co.kr/learn/courses/30/lessons/12914)

# 나의 풀이

```swift
func solution(_ n: Int) -> Int {
    guard n != 1 else { return 1 }
    var arr = [1, 2]
    
    for i in 2...n {
        arr.append((arr[i-2] + arr[i-1]) % 1234567)
    }
    return arr[n-1]
}
```

- `n`이 커지면서 생기는 규칙을 찾을 수 있었는데, 피보나치 수열과 비슷하다는걸 느낄 수 있습니다.
- `n`이 3인 경우의 수는 `n`이 1, 2일때의 경우의 수를 합친 것과 같습니다.
- `n`의 멀리뀌기의 경우의 수는 `n-1`의 경우의 수와 `n-2`의 경우의 수를 더하면 됩니다.
- 1234567의 나머지를 구하는 이유는 수열을 계속해서 만들게 되면 `Swift`의 `Int`범위를 넘어서는 수가 발생할 수 있고 런타임 오류를 발생합니다.
- 수열을 저장하는 것이 아닌, 1234567로 나눈 나머지를 결과값으로 저장합니다.

| n | 경우의 수 |  |
|:---:|:---:|:---:|
| 1 | 1 | (1) |
| 2 | 2 | (1,1) (2) |
| 3 | 3 | (1,1,1) (2,1) (1,2) |
| 4 | 5 | (1,1,1,1) (2,1,1) (1,2,1) (1,1,2) (2,2) |
| 5 | 8 | (1,1,1,1,1) (2,1,1,1) (1,2,1,1) (1,1,2,1) (1,1,1,2) (2,2,1) (2,1,2) (1,2,2) |

# 동적계획법(Dynamic Programming, DP)

[https://babbab2.tistory.com/100](https://babbab2.tistory.com/100)

- 나도 모르게 동적계획법를 사용하고 있다는 걸 알게 되었다.
- 상향식 접근법으로, **가장 작은 부분의 해답**을 구한 후, 이를 **저장**하여 저장한 값을 이용해 **상위 문제를 풀어가는 방식**
- 동적계획의 핵심은 `Memoization`기법으로 동일한 계산을 반복해야 할때, 이전에 계산한 값을 메모리에 저장하여 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 한다.
- 나의 풀이가 완전한 동적계획법을 사용한 풀이라고 할 수 있겠다.

# 순열과 조합

[https://www.youtube.com/watch?v=dIjKERG9TmQ](https://www.youtube.com/watch?v=dIjKERG9TmQ)

- 어쩌다 보니 강의를 보게 되었는데, 수학공부를 해야함을 느끼게 되었다.
- 수학을 잘하면 당연히 문제도 잘 풀 수 밖에 없구나라는 생각을 가지게 되었다.
